Практикум СУБД ВШПИ
Общие сведения
Программное обеспечение
Для выполнения заданий практикума предлагается использовать СУБД PostgreSQL
После установки/развертывания СУБД PostgreSQL можно использовать встроенные
клиенты cmd (psql) или GUI (pgAdmin4, VSCode, DataGrip, dBeaver).
СУБД PostgreSQL является бесплатным и свободно распространяющимся ПО, однако
существуют также производные коммерческие разработки. К таким можно отнести
СУБД PostgreSQL Pro. Для нее существует достаточно подробная документация на
русском языке, которая также актуальна для СУБД PostgreSQL, так как СУБД
PostgreSQL Pro является ее расширением и наследует всю функциональность:
https://postgrespro.ru/docs/postgrespro/16/index
Полезный ресурс по СУБД Postgres:
https://www.postgresqltutorial.com
Также можно воспользоваться англоязычной документацией для СУБД
PostgreSQL:
https://www.postgresql.org/docs/16/index.html
Порядок сдачи и сроки
Практические задания предполагают предварительную теоретическую и практическую
подготовку студента, которую он демонстрирует в процессе сдачи задания. Кроме того, в
процессе сдачи задания студент может получить дополнительные вопросы, ответы на
которые необходимо дать до окончания занятия.
За одно занятие допускается сдача не более трех заданий.
В таблице успеваемости будут проставляться оценки и штрафные баллы за каждое
практическое задание:
Просьба следить за своими оценками и сообщать преподавателям в случае
обнаружения ошибок.
Итоговая оценка
Для получения положительной оценки необходимо сдать все задания. По результатам
выполнения практических заданий в конце семестра выставляется оценка.
Одним из основных применений РСУБД является хранение и обработка данных
пользовательских приложений. Специфика такого использования заключается в том, что
данные постоянно добавляются/изменяются/удаляются. Схема данных достаточно
устойчива и редко изменяется. В этом случае непосредственно с СУБД взаимодействует
не человек, а программа, что уменьшает требования к способу взаимодействия с базойданных. Однако разработчику необходимо уметь проектировать гибкую и эффективную
схему данных, использовать ограничения целостности, манипулировать данными и
понимать механизмы поддержки согласованности базы данных, такие как транзакции и
триггеры.
Блок практических заданий 1.4, 2.1 призван сформировать у студента понимание
особенностей хранения, умение настраивать и поддерживать данные.

Практическое задание No1.4 Контроль целостности данных
Постановка задачи
Практическое задание посвящено контролю целостности данных, который
производится с помощью механизма транзакций и триггеров. Транзакции позволяют
рассматривать группу операций как единое целое, либо отрабатывают все операции,
либо ни одной. Это позволяет избегать несогласованности данных. Триггеры
позволяют проверять целостность данных в момент выполнения транзакций,
поддерживать целостность, внося изменения, и откатывать транзакции, приводящие к
потере целостности.
Необходимо подготовить SQL-скрипты для проверки наличия аномалий (потерянных
изменений, грязных чтений, неповторяющихся чтений, фантомов) при параллельном
исполнении транзакций на различных уровнях изолированности SQL/92 (READ
UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE).
Подготовленные скрипты должны работать с таблицей, содержащей 3-4 атрибута и до
30 строк. Для проверки наличия аномалий потребуются два параллельных сеанса,
операторы в которых выполняются пошагово:
Установить в обоих сеансах уровень изоляции READ COMMITED/READ
UNCOMMITTED (для postgresql это синонимы). Выполнить сценарии проверки
наличия аномалий потерянных изменений и грязных чтений.
Установить в обоих сеансах уровень изоляции READ COMMITTED. Выполнить
сценарии проверки наличия аномалий грязных чтений и неповторяющихся чтений.
Установить в обоих сеансах уровень изоляции REPEATABLE READ. Выполнить
сценарии проверки наличия аномалий неповторяющихся чтений и фантомов,
сериализации.
Установить в обоих сеансах уровень изоляции SERIALIZABLE. Выполнить
сценарий проверки фиксации аномалии сериализации.
Необходимо составить скрипт для создания 1-2х триггеров, а также подготовить
несколько запросов для проверки и демонстрации его полезных свойств:

Изменение данных для сохранения целостности.
Проверка транзакций и их откат в случае нарушения целостности.
Темы для проработки

Понятие транзакции, свойства транзакций.
https://postgrespro.ru/docs/postgrespro/16/tutorial-transactions
Уровни изолированности и аномалии
https://postgrespro.ru/docs/postgrespro/16/transaction-iso
Триггеры и триггерные функции
https://postgrespro.ru/docs/postgrespro/16/trigger-definition
https://postgrespro.ru/docs/postgrespro/16/plpgsql-trigger
Сообщения и ошибки
https://postgrespro.ru/docs/postgrespro/16/plpgsql-errors-and-messages
Полное описание синтаксиса встретившихся команд
https://postgrespro.ru/docs/postgrespro/16/sql-commandsПримеры вопросов

Рассказать об аномалиях доступа к БД.
Перечислить аномалии, возникающие на каждом из уровней
изолированности.
Рассказать о свойствах транзакций.
Рассказать об управлении транзакциями.
Что такое тупики? Как бороться с тупиками?
На каком уровне изолированности возможны тупики?
Как обеспечивается изолированность транзакций в СУБД?
Как бороться с проблемой фантомов?
Что такое журнал транзакций?
Как обеспечивается постоянство хранения (durability) в СУБД?
Объяснить принцип работы написанного триггера.
Какие бывают типы триггеров?
Когда может срабатывать триггер?
В каком порядке срабатывают триггеры?
Можно ли менять порядок срабатывания триггеров?
Сработает ли триггер, если оператор, выполненный пользователем, не
затрагивает ни одну строку таблицы?
Продемонстрировать откат транзакции при возникновении ошибок.
Продемонстрировать возникновение тупика.
Исправить неверные сценарии проверки аномалий
Исправить ошибки в работе триггера.
Модифицировать триггер каким-либо образом.

Практическое задание No2.1 Управление доступом
Постановка задачи
Целью практического задания является освоение работы с представлениями
и другими способами управления доступом. При выполнении задания
необходимо:

Создать пользователя test и выдать ему доступ к базе данных.
Составить и выполнить скрипты присвоения новому пользователю прав доступа к
таблице, созданной в практическом задании No1.4. При этом права доступа к
различным таблицам должны быть различными, а именно:
o По крайней мере, для одной таблицы новому пользователю
присваиваются права SELECT, INSERT, UPDATE в полном объеме.
o По крайней мере, для одной таблицы новому пользователю присваиваются
права SELECT и UPDATE только избранных столбцов.
o По крайней мере, для одной таблицы новому пользователю
присваивается только право SELECT.
Составить SQL-скрипты для создания нескольких представлений, которые
позволяли бы упростить манипуляции с данными или позволяли бы ограничить
доступ к данным, предоставляя только необходимую информацию.
Присвоить новому пользователю право доступа (SELECT) к одному из
представлений

Создать стандартную роль уровня базы данных, присвоить ей право доступа
(UPDATE на некоторые столбцы) к одному из представлений, назначить
новому пользователю созданную роль.
Выполнить от имени нового пользователя некоторые выборки из таблиц и
представлений. Убедиться в правильности контроля прав доступа.
Выполнить от имени нового пользователя операторы изменения таблиц с
ограниченными правами доступа. Убедиться в правильности контроля прав доступа.

Используя psql выполнить макрокоманду /dp и описать флаги доступа.
Темы для проработки

Роли и пользователи.
https://postgrespro.ru/docs/postgresql/16/user-manag
https://postgrespro.ru/docs/postgrespro/16/app-createuser
Директивы GRANT и REVOKE.
https://postgrespro.ru/docs/postgrespro/16/ddl-priv
https://postgrespro.ru/docs/postgrespro/16/ddl-schemas#DDL-SCHEMAS-PRIV
Представления.
https://postgrespro.ru/docs/postgrespro/16/sql-createview
https://postgrespro.ru/docs/postgrespro/16/rules-views
https://postgrespro.ru/docs/postgrespro/16/rules-materializedviews
Полное описание синтаксиса встретившихся команд
https://postgrespro.ru/docs/postgrespro/16/sql-commands
Примеры вопросов

Для чего нужны роли?
Что такое схема?
Рассказать про директивы GRANT и REVOKE.
Для чего нужна роль PUBLIC?
 Как добавить нового пользователя в текущую базу данных? Как
позволить пользователю заходить на сервер?
 Какие существуют права?
 Исправить ошибки в обязательной части.
Сменить владельца базы данных.
 Сменить пароль для пользователя.
 Определить роль с заданными правами.
 Объяснить, как работают написанные запросы.
 Рассказать о CHECK OPTION.
 Рассказать о модификации данных через представления.
 Рассказать о вставке данных через представления.
 Исправить неверно работающий запрос (запросы).
 Упростить один или несколько запросов.
Продемонстрировать изменение и вставку данных через представления. Написать или
модифицировать запрос по сформулированному заданию. Продемонстрировать
полезность материализованного представления.

Практическое задание No3.1 Проектирование аналитической схемы базы
данных
Постановка задачи
Седьмое практическое задание связано с проектированием схемы базы данных для аналитики.
Будем исходить из того, что приложение, для которого была сделана база данных в задании стала
очень популярной и по ней каждый день можно собирать большой объем статистической
информации. Результатом данного практического задания являются: скрипты создания базы
данных, хранимая процедура (генератор) для ее заполнения, анализ плана выполнения запроса.
Пример используемой ER диаграммы (система доставки UPS)
ссылка. Можно использовать эту или любую другую похожую по сложности диаграмму
аналитической БД.
Требования к БД

Одна таблица (Item transportation) должна содержать не меньше 10 млн. записей, которые со
временем теряют актуальность.
Другая таблица (Shipped Item), связанная с первой, должна содержать не меньше 1 млн.
записей.
Остальные таблицы должны содержать по 5-10 записей.
В одной из таблиц с количеством записей 1 млн. должна быть колонка с текстом, по которой
будет необходимо настроить полнотекстовый поиск.
Практическая часть включает:
1) наполнение таблицы, для этого нужно написать хранимую процедуру - генератор на языке
plpython3u, которая использует словари (для строковых типов), случайные значения (для
строковых, числовых типов).
2) оценку скорости выполнения запросов.
Для этого могут быть использованы механизмы секционирования, наследования и индексов.
Необходимо подготовить два запроса:
• Запрос к одной таблице, содержащий фильтрацию по нескольким полям.
• Запрос к нескольким связанным таблицам, содержащий фильтрацию по нескольким полям.
3) оценка скорости полнотекстового поиска (использование функций to_tsvector to_tsquery)Для каждого из этих запросов необходимо провести следующие шаги:

•Получить план выполнения запроса без использования индексов (удаление индекса или
отключение его использования в плане запроса).
Получить статистику (IO и Time) выполнения запроса без использования индексов.
Создать нужные индексы, позволяющие ускорить запрос.
Получить план выполнения запроса с использованием индексов и сравнить с первоначальным
планом.
Получить статистику выполнения запроса с использованием индексов и сравнить с
первоначальной статистикой.
Оценить эффективность выполнения оптимизированного запроса.
•Синтаксис EXPLAIN:

EXPLAIN [ ( параметр [, ...] ) ] оператор
EXPLAIN [ ANALYZE ] [ VERBOSE ] оператор
Здесь допускается параметр:
ANALYZE [ boolean ]
VERBOSE [ boolean ]
COSTS [ boolean ]
SETTINGS [ boolean ]
BUFFERS [ boolean ]
WAL [ boolean ]
TIMING [ boolean ]
SUMMARY [ boolean ]
FORMAT { TEXT | XML | JSON | YAML }
В PGAdmin удобно использовать следующий формат команды
EXPLAIN (ANALYZE, VERBOSE, COSTS, TIMING, FORMAT JSON)
Также необходимо продемонстрировать полезность индексов для организации полнотекстового
поиска.
Для таблицы объемом 10 млн. записей произвести оптимизацию, позволяющую быстро удалять
старые данные, ускорить вставку и чтение данных.
Темы для проработки

Наполнение базы данных
https://postgrespro.ru/docs/postgrespro/16/populate
EXPLAIN
https://postgrespro.ru/docs/postgrespro/16/using-explain
https://postgrespro.ru/docs/postgrespro/16/planner-stats
https://postgrespro.ru/docs/postgrespro/16/explicit-joins
https://explain.tensor.ru/
ANALYZE
https://postgrespro.ru/docs/postgrespro/16/routine-vacuuming#VACUUM-FORSTATISTICS
Индексы
https://postgrespro.ru/docs/postgrespro/16/indexes
Полнотекстовый поиск
https://postgrespro.ru/docs/postgrespro/16/textsearch
Наследование таблиц
https://postgrespro.ru/docs/postgrespro/16/ddl-inherit
Секционирование таблиц•
https://postgrespro.ru/docs/postgrespro/16/ddl-partitioning
Полное описание синтаксиса встретившихся команд
https://postgrespro.ru/docs/postgrespro/16/sql-commands
Примеры вопросов

В чем отличие первичного ключа и уникального индекса?
В каких случаях имеет смысл создавать индексы? Какие колонки следует включать в индекс и
почему?
Какие существуют способы внутренней организации индексов?
Рассказать о проблеме фрагментации индексов. Как бороться с фрагментацией?
Имеет ли значение порядок указания колонок при создании индекса?
В чем разница между Index Scan и Index Seek?
В чем разница между секционированием и наследованием?
Зачем нужен ANALYZE?
Исправить ошибки в подготовленных выборках.
Могут ли индексы ухудшить производительность? Если да, то продемонстрировать это.
На что влияет порядок сортировки (ASC\DESC) при создании индекса? Продемонстрировать
это.
Продемонстрировать полезность индекса по выражению.
Продемонстрировать полезность частичного индекса.

Практическое задание No3.2 Использование документно-ориентированных
объектов типа Json.
Постановка задачи
PostgreSQL стала первой реляционной базой данных, поддерживающей слабоструктурированные
данные. В PostgreSQL для этого используется JSON (JavaScript Object Notation, Запись объекта
JavaScript RFC 7159), который имеет два представления: json и jsonb. Для реализации
эффективного механизма запросов к этим типам данных в Postgres также имеется тип jsonpath.
Официально JSON появился в PostgreSQL в 2014 году. PostgreSQL с JSONB совмещает гибкость
NoSQL , а также надёжность и богатство функциональности реляционных СУБД.
В практической части необходимо:

создать БД IMDB test, использующую стандартные атрибуты и атрибут jsonb. Ссылка на
интефейсы. Используется один файл actors.list.txt с я.диска из папки DataSet. Описание файла:
кодовая страница ISO 8859-1
используемые разделители HT (0x09) horizontal_tab, LF (0x0A) line_feed.
Для полей используется один или несколько разделителей HT, для ролей актера один LF,
для актеров два LF
Правила синт. разбора поля Titles
a. первый атрибут title или "title" = название роли, переносим в json с одинарными
кавычками или без кавычек.
b. второй атрибут (year) = год роли, первые круглые скобки, может быть (????) - дата
неизвестна.c. третий атрибут/необязательный (type1) = тип материала, все что после года в
круглых скобках: (V)- видео или клип,
(TV)- для телевидения,
(VG)- для видео игры,
(archive footage) - архивные или ранние кадры,
(uncredited) – не зарегистрирован или не указан в титрах,
(voice) - озвучка или закадровый голос,
может иметь несколько атрибутов одновременно, тогда следует именовать ключи как
type1, type2, type3, т.к. в jsonb все ключи должны быть разными.
d. четвертый атрибут/необязательный {series name} = название серии в сериале: в
фигурных скобках, #xx.yy = номер_сезона/номер_серии.
e. пятый атрибут/необязательный (as character) = пояснение имени героя: находится в
скобках перед именем героя, добавляем в json к ключу “character name” в конце как
есть в скобках.
f. шестой атрибут/необязательный [character name]= имя героя: в квадратных скобках.
g. седьмой атрибут/необязательный <credit> = номер в титрах: в треугольных скобках.
Исключения из правил при разборе
реальные данные неидеальны, файл с актерами тоже, т.о. есть строки, которые не
описываются диаграммой разбора. Это необходимо учесть.
Примеры исключений:
внутри роли разделители пробелы
имена,фамилии включают скобки и разные странные символы
отставляем как есть
поле (as character ) может повторяться как (also as character) игнорировать или
добавить еще type
(2014/III)
замена на (2014)
(????)
замена на (0000)
(????/III)
замена на (0000)
вариант шаблона файла
две первые строки- заголовок списка ролей
SecondName, FirstName HT HT HT
title (year)
[character name] <credit> LF
HT HT HT
title (year) (type1) [character name]
LF
LF
SecondName, FirstName
HT
title
(year)
[character name] <credit> LF
HT HT HT
title
(year) {series name} (type1) (type2) [character name] <credit> LF
HT HT HT
title
(year) (as character)
[character name]
LF
поля СУБД
id
ActorName
RolesName
integer (PRIMARY KEY генерируется из последовательности)
varchar (из поля Name в формате FirstName SecondName)
jsonb
(из поля Titles по правилу разбора)
пример записи таблицы
id
*****
ActorName
"Morgan Freeman"
RolesName
{
"roles": [
{
"title": The Shawshank Redemption,
"year": "1994",
"character name": "Ellis Boyd 'Red' Redding",
"credit": "2"
},{
"title": The True Story of Glory Continues,
"year": "1991",
"type1": "voice",
"character name": "Narrator",
"credit": "1"
},
{
"title": Unforgiven,
"year": "1992",
"character name": "Ned Logan",
"credit": "1"
}
{
"title": Through the Wormhole,
"year": "2010",
"series name": "Are Aliens Inside Us? (#6.5)"
"character name": "Himself - Narrator"
"credit": "1"
}
],
}

Составить 3-4 запроса с использованием api postgresql (3 варианта) для jsonb.
Измерить время доступа к полю jsonb для каждой строчки (в виде таблицы или графика).
Оценить влияние длины строки на скорость доступа (ожидается ступенька до 2kB, после
линейная зависимость). Для этого следует измерить время чтения year первой роли актера
(explain analyze). Для точности оценки важно учитывать хранимую длину (jsonb хранится в
сжатой форме). Как можно это влияние уменьшить?
Составить запрос на изменение year у первой роли актера. Сравнить изменение объема БД
для актера с малым кол-вом ролей и актера с большим количеством ролей (toasted roles).
Темы для проработки

Денормализация
https://habr.com/ru/company/latera/blog/281262
https://habr.com/ru/post/64524
Json
https://postgrespro.ru/docs/postgrespro/16/datatype-json
https://postgrespro.ru/docs/postgrespro/16/functions-json
https://habr.com/ru/company/oleg-bunin/blog/646987/Примеры вопросов

В чем отличие типов json и jsonb?
Какие типы индексации поддерживает jsonb?
Что такое jsonpath?
Что такое toasted object?

