\subsection{Тестирование}

\subsubsection{Метод прогонки}

Сначала протестируем на простом случае
\begin{align*}
a = \begin{pmatrix} 0 & 0 & 0 \end{pmatrix}^\mathsf{T} \quad
b = \begin{pmatrix} 0 & 0 & 0 \end{pmatrix}^\mathsf{T} \quad
c = \begin{pmatrix} 1 & 1 & 1 \end{pmatrix}^\mathsf{T} \quad
g = \begin{pmatrix} 1 & 1 & 1 \end{pmatrix}^\mathsf{T}
\end{align*}
Очевидно что ответ \(u = \begin{pmatrix} 1 & 1 & 1 \end{pmatrix}^\mathsf{T}\)

Потом возьмем пример из задачника
\begin{align*}
a = \begin{pmatrix} 0 & 2 & 2 & 3 \end{pmatrix}^\mathsf{T} \quad
b = \begin{pmatrix} -1 & -1 & -0.8 & 0 \end{pmatrix}^\mathsf{T} \quad
c = \begin{pmatrix} 5 & 4,6 & 3,6 & 4,4 \end{pmatrix}^\mathsf{T} \\
g = \begin{pmatrix} 2 & 3,3 & 2,6 & 7,2 \end{pmatrix}^\mathsf{T} \quad
u = \begin{pmatrix} 0.5256 & 0.628 & 0.64 & 1.2 \end{pmatrix}^\mathsf{T}
\end{align*}

Для каждого из тестов посчитаем разницу полученного решения и истинного (u) и выберем наибольший по модулю элемент полученного вектора

1. 0

2. 1.1E-16

\subsubsection{Интегро-интерполяционный метод}

Выполним нашу программу на ряде входных параметров. Берем тестовые k, q, u, R, $\chi$, потом вычисляем f, $\nu$.

\begin{table}[H]
  \centering
  \begin{tabular}{ c | *{8}c }
    \toprule
    Номер теста & k & q & u & R & $\chi $ & f & $\nu $ \\
    \midrule
    1 & 3r & 4r+3 & 1 & 1 & 1 & 4r+3 & 1 \\
    \midrule
    2 & $ r+1 $ & $ 2r+2 $ & $ r^2 $ & 1 & 1 & $ 2r^3+2r^2-6r-4 $ & 5 \\
    \bottomrule
  \end{tabular}
\end{table}

Первый тест характеризуется отсутствием погрешности разностной схемы, а второй - присутствием.

После запуска программы мы получаем следующие результаты. Выпишем наибольшие по модулю элементы вектора разности истинного решения с полученным для разного значения N – количество отсчетов.

  \begin{table}[H]
    \centering
    \begin{tabular}{c | c | c}
      \toprule
      N & Тест 1 & Тест 2 \\
      \midrule
4 & 0.0E+00 & 4.1E-02 \\
8 & 0.0E+00 & 1.0E-02 \\
16 & 0.0E+00 & 2.6E-03 \\
32 & 0.0E+00 & 6.5E-04 \\
64 & 2.6E-05 & 1.4E-04 \\
128 & 4.3E-05 & 2.4E-05 \\
256 & 1.0E-05 & 3.9E-05 \\
512 & 6.1E-05 & 6.4E-05 \\
1024 & 8.9E-05 & 9.0E-05 \\
2048 & 6.0E-02 & 4.5E-02 \\
4096 & 1.0E-01 & 5.4E-02 \\
8192 & 3.4E-01 & 2.8E+00 \\

      \bottomrule
    \end{tabular}
    \caption{Наибольшие по модулю элементы вектора разности истинного решения с полученным (погрешности)}
  \end{table}

Видно, что для первого теста ошибок сначала нет, а потом они появляются и растут. Так происходит потому что ошибок разностной схемы то тут нет а решить СЛАУ для небольшого N совсем просто.

Для второго теста ошибка сначала падает, а потом растет. Можно заметить что рост начинается как раз когда ошибка доходит до порядка -5. Дальше она растет похожим на тест 1 образом.

Покажем во сколько раз убывают погрешности во втором тесте с ростом N.

  \begin{table}[H]
    \centering
    \begin{tabular}{c | c}
      \toprule
      N & Тест 2 \\
      \midrule
4 & 3.9 \\
8 & 4.0 \\
16 & 4.0 \\
32 & 4.7 \\
64 & 5.9 \\
128 & 0.6 \\
256 & 0.6 \\
512 & 0.7 \\
1024 & 0.0 \\
2048 & 0.8 \\
4096 & 0.0 \\

      \bottomrule
    \end{tabular}
    \caption{Отношения погрешностей (текущее к следующему)}
  \end{table}

Можно проследить зависимость погрешности от числа разбиений, которую мы выявили в предыдущей главе - при увеличении шага в 2 раза погрешность должна уменьшаться примерно в 4 раза.

Все вычисления проведены с одинарной точностью.

% На тесте 1 можно видеть линейное падение погрешности, так как в случае u=1 все производные начиная с первой равны нулю и $ h^3 \cdot 0 = 0 $. Остается только линейное слагаемое в формуле погрешности основного уравнения.
% Также можно проследить что есть число разбиений при котором погрешность минимальна. При дальнейшем увеличении числа разбиений погрешность увеличивается (данное явление можно заметить на тестах одинарной точности).
