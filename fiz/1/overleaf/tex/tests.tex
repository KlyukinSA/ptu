\subsection{Тестирование}

\subsubsection{Метод прогонки}

Сначала протестируем на простом случае
\begin{align*}
a = \begin{pmatrix} 0 & 0 & 0 \end{pmatrix}^\mathsf{T} \quad
b = \begin{pmatrix} 0 & 0 & 0 \end{pmatrix}^\mathsf{T} \quad
c = \begin{pmatrix} 1 & 1 & 1 \end{pmatrix}^\mathsf{T} \quad
g = \begin{pmatrix} 1 & 1 & 1 \end{pmatrix}^\mathsf{T}
\end{align*}
Очевидно что ответ \(u = \begin{pmatrix} 1 & 1 & 1 \end{pmatrix}^\mathsf{T}\)

Потом возьмем пример из задачника
\begin{align*}
a = \begin{pmatrix} 0 & 2 & 2 & 3 \end{pmatrix}^\mathsf{T} \quad
b = \begin{pmatrix} -1 & -1 & -0.8 & 0 \end{pmatrix}^\mathsf{T} \quad
c = \begin{pmatrix} 5 & 4,6 & 3,6 & 4,4 \end{pmatrix}^\mathsf{T} \\
g = \begin{pmatrix} 2 & 3,3 & 2,6 & 7,2 \end{pmatrix}^\mathsf{T} \quad
u = \begin{pmatrix} 0.5256 & 0.628 & 0.64 & 1.2 \end{pmatrix}^\mathsf{T}
\end{align*}

Для каждого из тестов посчитаем разницу полученного решения и истинного (u) и выберем наибольший по модулю элемент полученного вектора

1. 0

2. 1.1E-16

\subsubsection{Интегро-интерполяционный метод}

Выполним нашу программу на ряде входных параметров. Берем тестовые k, q, u, R, $\chi$, потом вычисляем f, $\nu$.

\begin{table}[H]
  \centering
  \begin{tabular}{ c | *{8}c }
    \toprule
    Номер теста & k & q & u & R & $\chi $ & f & $\nu $ \\
    \midrule
    1 & 3r & 4r+3 & 1 & 1 & 1 & 4r+3 & 1 \\
    \midrule
    2 & $ r+1 $ & $ 2r+2 $ & $ r^2 $ & 1 & 1 & $ 2r^3+2r^2-6r-4 $ & 5 \\
    \bottomrule
  \end{tabular}
\end{table}

Первый тест характеризуется отсутствием погрешности разностной схемы, а второй - присутствием.

После запуска программы мы получаем следующие результаты. Выпишем наибольший по модулю  элемент вектора разности истинного решения с полученным для разного значения N – количество отсчетов.

  \begin{table}[H]
    \centering
    \begin{tabular}{c | c | c}
      \toprule
      N & $ \left\lVert \varepsilon \right\rVert  $, Тест 1 & $ \left\lVert \varepsilon \right\rVert  $, Тест 2 \\
      \midrule
4 & 1.1E-01 & 4.1E-02 \\
8 & 6.4E-02 & 1.0E-02 \\
16 & 3.5E-02 & 2.6E-03 \\
32 & 1.8E-02 & 6.5E-04 \\
64 & 9.3E-03 & 1.6E-04 \\
128 & 4.7E-03 & 4.1E-05 \\
256 & 2.4E-03 & 1.0E-05 \\
512 & 1.2E-03 & 2.6E-06 \\
1024 & 6.0E-04 & 6.4E-07 \\
      \bottomrule
    \end{tabular}
    \caption{Погрешности}
  \end{table}

  \begin{table}[H]
    \centering
    \begin{tabular}{c | c | c}
      \toprule
      N & $ \left\lVert \varepsilon \right\rVert  $, Тест 1 & $ \left\lVert \varepsilon \right\rVert  $, Тест 2 \\
      \midrule
4 & 1.7 & 3.9 \\
8 & 1.8 & 4.0 \\
16 & 1.9 & 4.0 \\
32 & 1.9 & 4.0 \\
64 & 2.0 & 4.0 \\
128 & 2.0 & 4.0 \\
256 & 2.0 & 4.0 \\
512 & 2.0 & 4.0 \\
      \bottomrule
    \end{tabular}
    \caption{Отношения погрешностей (текущее к следующему)}
  \end{table}
Все вычисления проведены с двойной точностью.

На тесте 2 можно проследить зависимость погрешности от числа разбиений, которую мы выявили в предыдущей главе - при увеличении шага в 2 раза погрешность должна уменьшаться примерно в 4 раза.

На тесте 1 можно видеть линейное падение погрешности, так как в случае u=1 все производные начиная с первой равны нулю и $ h^3 \cdot 0 = 0 $. Остается только линейное слагаемое в формуле погрешности основного уравнения.
% Также можно проследить что есть число разбиений при котором погрешность минимальна. При дальнейшем увеличении числа разбиений погрешность увеличивается (данное явление можно заметить на тестах одинарной точности).
