Разработка blockchain на python

1.2. Задание

Необходимо создать простейший blockchain на python, имитирующий работу
цепочки блоков, связанных между собой с помощью хеширования и ссылки на предыдущий
блок. Блоки содержат внутри себя некоторые данные, представленные в текстовом виде,
время их создания, хеш предыдущего блока, работающий по консенсусу proof of work. Для
цепи необходимо реализовать проверку её валидности путём сравнения хешей
рассчитываемых блоков. Возможность указания временной сложности добычи блока и
сложности хеширования в формате “00000000”.

1.3. Создание blockchain на python

Перед началом работы следует подключить библиотеку hashlib, поддерживающую
OpenSSL, позволяющую работать с различными криптографическими функциями, а также
библиотеку time. Под блокчейном примем некую систему, где необходимо выполнить
некую работу для добавления нового блока в цепь.
Для создания блокчейна необходимо реализовать классы: block, blockchain.

1.1.1.
Класс Block.

Описывает отдельный блок в цепи, содержит такие
поля как:
- временная метка (timestamp) – время создания блока, используемое для
расчёта хеша в дальнейшем
- данные (data) – какие-либо данные передаваемые в блоке при
транзакции
- хеш предыдущего блока, на который ссылается текущий, обозначаем
за Null для первого блока, т.к. предыдущего у него нет
- Уникальное
случайное
число
(nonce) -
случайное
или
псевдослучайное уникальное число, которое используется только единожды.
Используется как переменная в процессе добычи блоков. Необходимо найти
подходящее
число,
генерируемое
хешом,
соответствующее
определённым
условиям, в таком случае создаётся блок. Сложность принято задавать количеством
нулей “000000”.
- Хеш текущего блока, получаемый с помощью метода расчёта хеша

1.1.2. Метод
getHash(), возвращающий
хеш,
использует
SHA256,
рассчитывается на основании предыдущего хеша, временной метки, данных, nonce.
Для этого их необходимо приводить к необходимой кодировке encode('utf-8'), а
также приводить к строке STR()
Для обновления хеша используется hash.update от перечисленного выше
Далее необходимо перевести полученное к побитовому виду hexdigest()

1.1.3. Метод mine(), вычисляющий хеш до тех пор, пока не будет найден
нужный по заданной сложности. С каждым проходом инкриминируем nonce и
обновляем значение hash. Сложность вычисляется как количество нулей
‘0’*difficulty

1.1.4. Класс Blockchain. 

Cодержит сложность, временную сложность вычисления
блока в мс, саму цепочку блоков. В нём необходимо реализовать следующие
методы:
- Получение последнего блока
- Добавление нового блока в цепочку
- Проверка цепи проверяет хеши блоков и предыдущих блоков,
проходясь поочередно по цепи, i начиная с 1, т.к. первый блок задаётся
пользователем, а не рассчитывается по предыдущим

На этом минимальное необходимые для реализации моменты заканчиваются,
использование nonce и сложности позволяет провести проверку proof of work для цепи.
Остается создать первый блок, рассчитать последующие и записать в файл результат
работы программы в следующем формате для текущего блока и предыдущего:
```
Data:
Timestamp:
Nonce:
Hash:
PrevHash:
```
Для реализации задания опционально можно использовать http запросы, flasc и
прочие сетевые фреймворки.


